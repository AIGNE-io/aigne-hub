# データ永続化

このシステムのデータ永続化レイヤーは、Promise ベースの Node.js ORM である [Sequelize](https://sequelize.org/) を基盤とし、データベースエンジンとして [SQLite](https://www.sqlite.org/index.html) を使用しています。この設計選択は、シンプルさ、デプロイの容易さ、そして外部依存の最小化を優先しており、システムを自己完結型で管理しやすいものにしています。

## データベース設定

コアとなるデータベース設定は `blocklets/core/api/src/store/sequelize.ts` 内で管理されています。システムは単一の SQLite データベースファイルに接続し、すべての永続データが予測可能な場所に保存されるようにしています。

-   **接続 URL**: `sqlite:${Config.dataDir}/aikit.db`
-   **データベースファイル**: 設定されたデータディレクトリに配置される `aikit.db`。

### パフォーマンスと同時実行性のチューニング

同時読み書き操作を最適化し、パフォーマンスを向上させるため、初期化時にいくつかの SQLite PRAGMA ディレクティブが設定されます。これらの設定は、負荷がかかった状態でのシステムの応答性を維持するために不可欠です。

-   `pragma journal_mode = WAL;`: 先行書き込みログ (WAL) モードは、あるプロセスがデータベースに書き込んでいる間もリーダーが操作を継続できるようにすることで、より高い同時実行性を可能にします。これにより、リーダーとライターの競合が大幅に減少します。
-   `pragma synchronous = normal;`: WAL モードでは、この設定により、書き込みトランザクションはリターンする前に WAL ファイルにコミットされますが、実際のディスク同期のタイミングは OS が担当します。これはパフォーマンスと耐久性の間で良好なバランスを提供します。
-   `pragma journal_size_limit = 67108864;`: WAL ファイルのサイズに上限 (64 MB) を設定し、ファイルが無限に増大して過剰なディスクスペースを消費するのを防ぎます。

## スキーマ管理とマイグレーション

データベーススキーマのマイグレーションは [Umzug](https://github.com/sequelize/umzug) によって処理され、データベースの変更が管理され、バージョン管理され、再現可能な方法で適用されることを保証します。マイグレーションロジックは `blocklets/core/api/src/store/migrate.ts` にあります。

-   **マイグレーションファイル**: マイグレーションは `**/migrations/` ディレクトリ内にある `.ts` または `.js` ファイルとして定義されます。Umzug はアプリケーション起動時に保留中のマイグレーションを自動的に検出し、実行します。
-   **安全なスキーマ更新**: システムには、一般的なデプロイエラーを防ぐために `safeApplyColumnChanges` や `createIndexIfNotExists` のようなヘルパー関数が含まれています。これらのヘルパーは、スキーマの変更 (カラムやインデックスの追加など) がまだ存在しない場合にのみ適用されることを保証し、マイグレーションスクリプトを冪等で再実行しても安全なものにします。

## データモデル

データベーススキーマは、システムのコアエンティティを表す、相互に接続されたいくつかのモデルに整理されています。

### コアモデルの概要

-   **AiProvider**: 外部の AI サービスプロバイダー (例: OpenAI, AWS Bedrock) を表します。ベース URL、リージョン、表示名などの設定詳細を保存します。
-   **AiCredential**: 各 `AiProvider` の認証情報を安全に保存します。単一プロバイダーに対して複数の認証情報間で負荷分散を行う機能が含まれています。
-   **AiModelRate**: プロバイダーが提供する特定の AI モデルのコスト構造とメタデータを定義します。これは各 API コールのクレジットコストを計算するために使用されます。
-   **ModelCall**: 主要な監査およびトランザクションログとして機能します。すべての AI リクエストがここに記録され、ユーザー、プロバイダー、モデル、使用状況メトリクス、最終ステータス (成功/失敗) に関する詳細がキャプチャされます。
-   **ModelCallStat**: `ModelCall` テーブルから派生した、時間ごとおよび日ごとの集計済み使用統計を保存するパフォーマンス最適化モデルです。ダッシュボードや分析クエリを高速化するために使用されます。
-   **App**: 認証のために公開鍵を含む、システムの使用を許可されたアプリケーションに関する情報を保存します。
-   **Usage**: トークン使用量とクレジット消費量を追跡するための補助モデルで、主に外部の支払いシステムへの報告に使用されます。

### `AiCredential`: セキュリティと負荷分散

`AiCredential` モデルは、セキュリティとシステムの信頼性の両方にとって非常に重要です。

#### 認証情報の暗号化

機密情報を保護するため、`api_key` や `secret_access_key` のような認証情報の値は平文では保存されません。これらは `@blocklet/sdk/lib/security` モジュールを使用して、データベースに永続化される前に暗号化されます。このモデルは、このプロセスを透過的に処理するために `encryptCredentialValue` と `decryptCredentialValue` メソッドを提供します。運用上の観点から、これは生のデータベースファイルが機密キーを公開しないことを意味しますが、アプリケーションの実行時環境は安全でなければなりません。

#### 認証情報の負荷分散

`getNextAvailableCredential` 静的メソッドは、スムーズな重み付きラウンドロビンアルゴリズムを実装しています。これにより、管理者は単一のプロバイダーに対して複数の認証情報を設定し、割り当てられた重みに基づいて API 負荷を分散させることができます。これは、次のような場合に役立ちます。

-   **レート制限の分散**: プロバイダーのレート制限に達するのを避けるために、複数のキーにリクエストを分散させます。
-   **高可用性**: 1つの認証情報が無効になった場合でも、システムは残りのアクティブな認証情報で運用を継続できます。
-   **使用量クォータ管理**: 異なるアカウントや請求階層に使用量を分散させます。

このアルゴリズムは、各認証情報の現在の重みをメモリ内に維持し、次のリクエストに最も適したものを選択することで、効率的でバランスの取れたトラフィックの分散を保証します。

### `ModelCall` と `ModelCallStat`: 分析とパフォーマンス

このシステムは、応答性の高いユーザーインターフェースを維持しながら、AI モデルの使用状況に関する詳細な分析を提供するように設計されています。これは、2層のデータモデル設計によって実現されています。

1.  **生データのロギング (`ModelCall`)**: すべての API リクエストは `ModelCalls` テーブルに単一のエントリとして記録されます。これにより、監査、詳細な分析、特定のリクエストのトラブルシューティングのための、粒度の細かい、完全な履歴が提供されます。しかし、この大きなテーブルで集計統計 (例: 日々の使用傾向) をクエリするのは遅く、リソースを大量に消費する可能性があります。

2.  **事前集計キャッシング (`ModelCallStat`)**: パフォーマンスの問題を解決するため、`ModelCallStat` モデルは `ModelCall` のデータの時間ごとおよび日ごとの事前計算された要約を保存します。過去の期間の分析データが要求された場合、システムはこの要約テーブルから読み取るため、大幅に高速になります。現在進行中の期間 (例: 今日または現在の時間) については、新鮮さを保証するために `ModelCall` テーブルからリアルタイムで統計が計算されます。このキャッシング戦略は、データの正確性とクエリパフォーマンスのバランスを取るための重要なアーキテクチャ上の決定です。

## 運用上の考慮事項

### バックアップとリストア

システムの全状態は `aikit.db` SQLite ファイルに保存されます。この単一ファイルをバックアップするだけで、すべてのデータを保存するのに十分です。

しかし、`WAL` モードを使用しているため、アプリケーション実行中の直接的なファイルコピー (`cp`) は、破損したバックアップにつながる可能性があるため、**推奨されません**。ライブバックアップを作成するための推奨手順は、SQLite CLI の `.backup` コマンドを使用することです。

```bash
sqlite3 /path/to/your/data/aikit.db ".backup '/path/to/your/backup/aikit.db.backup'"
```

このコマンドは、データベースが使用中であっても一貫したスナップショットを保証し、データベースの内容を安全に新しいファイルにコピーします。リストアは、アプリケーションを停止した状態で `aikit.db` ファイルをバックアップファイルに置き換えるだけで簡単に行えます。

### データ増加の管理

`ModelCalls` テーブルは、すべての API トランザクションをログに記録するため、無期限に増加するように設計されています。長期間のデプロイメントでは、これによりディスクスペースが大幅に消費され、詳細な履歴検索のクエリパフォーマンスが低下する可能性があります。

システム管理者は `aikit.db` ファイルのサイズを監視する必要があります。アプリケーションには組み込みのデータ整理やアーカイブメカニズムはありませんが、使用量に応じて戦略を実装する必要があるかもしれません。考えられる戦略としては、特定の日付より古い `ModelCall` レコードを定期的にコールドストレージにアーカイブし、その後ライブデータベースから削除することが挙げられます。