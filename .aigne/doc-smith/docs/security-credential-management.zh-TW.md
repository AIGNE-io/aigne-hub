# 負載均衡

AIGNE Hub 提供了一個強大的負載均衡機制，用來將 AI 請求分散到單一供應商的多個憑證上。這對於管理 API 速率限制、提高容錯能力以及優化成本至關重要。該系統的設計旨在使其在分發上既智慧化，又能應對憑證故障。

本文件將說明負載均衡系統的架構、所使用的演算法，以及供基礎設施團隊參考的營運考量。

## 架構概覽

當為單一 AI 供應商設定多個 API 金鑰或憑證時（例如，數個 OpenAI API 金鑰），AIGNE Hub 會將它們視為一個資源池。對於每一個指定給該供應商的傳入請求，負載均衡器會根據平滑加權輪詢演算法，從資源池中選擇最適合的憑證。

此系統的關鍵組件包括：

-   **憑證池**：特定供應商的有效憑證集合。
-   **權重系統**：每個憑證都可以被指派一個 `weight`（權重），以影響其被選中的頻率。
-   **健康狀態**：憑證可以被標記為 `active`（啟用）或 `inactive`（停用）。負載均衡器只會從啟用狀態的憑證池中進行選擇。
-   **使用情況追蹤**：系統會追蹤每個憑證的 `usageCount`（使用次數）和 `lastUsedAt`（上次使用時間），這有助於故障轉移並提供分發的可見性。

---

## 負載均衡演算法

AIGNE Hub 採用**平滑加權輪詢**（Smooth Weighted Round-Robin）演算法，以確保根據預先定義的權重，公平且可預測地分發請求。

### 運作方式

此演算法旨在避免請求突發性地集中到單一高權重憑證。相反地，它會平滑地將請求分散。以下是每個請求的選擇流程：

1.  **擷取啟用狀態的憑證**：系統會擷取目標供應商所有 `active` 標記為 `true` 的憑證。
2.  **更新目前權重**：一個記憶體內的快取會為每個憑證維護一個 `current`（目前）權重。在每次選擇執行時，每個憑證設定的 `weight`（權重）會被加到其 `current` 權重上。
3.  **選擇最佳憑證**：具有最高 `current` 權重的憑證會被選中來處理請求。
4.  **為下一個週期進行調整**：選擇後，憑證池中所有憑證的 `total weight`（總權重）會從被選中憑證的 `current` 權重中減去。

此過程確保了權重較高的憑證會隨著時間被更頻繁地選中，但其方式是交錯且平滑的。

### 設定

分發由每個憑證上的 `weight` 參數控制。

-   **`weight` (integer)**：預設值為 `100`。數字越大，發送到該憑證的請求比例就越高。

**範例情境：**

假設一個供應商有兩個憑證：
-   **金鑰 A**：`weight: 200`
-   **金鑰 B**：`weight: 100`

在一系列 300 個請求中，**金鑰 A** 大約會被選中處理 200 個請求，而**金鑰 B** 將處理約 100 個。平滑演算法確保了分發是均勻的，避免了例如金鑰 A 連續接收 200 個請求的情況。

### 程式碼實作

核心邏輯位於 `AiCredential` 模型的 `getNextAvailableCredential` 靜態方法中。此方法管理權重計算並選擇下一個憑證。

```typescript
// 來自：blocklets/core/api/src/store/models/ai-credential.ts

// 平滑加權輪詢的簡化邏輯
let selected: AiCredential | null = null;
for (const c of credentials) {
  const w = weights[c.id];
  if (w) {
    w.current += w.weight;
    if (!selected || w.current > weights[selected.id]!.current) {
      selected = c;
    }
  }
}

if (selected) {
  weights[selected.id]!.current -= totalWeight;
}

return selected;
```

---

## 故障轉移與健康管理

負載均衡器被設計為自動繞過發生故障的憑證，以確保服務的連續性。

### 自動停用

如果對 AI 供應商的請求因憑證特定問題（例如，無效的 API 金鑰）而失敗，該憑證可被標記為停用。

-   `active` 標記被設為 `false`。
-   一則詳述失敗原因的 `error` 訊息會被記錄在該憑證的記錄中。

一旦憑證被標記為停用，負載均衡器會立即將其從後續請求的選擇池中移除。

### 憑證重新啟用

被標記為停用的憑證必須手動重新驗證並重新啟用。`checkCredentials` 函式用於此目的。

1.  **觸發驗證**：管理員可以透過管理介面對停用的憑證觸發健康檢查。
2.  **測試連線**：系統使用該憑證對 AI 供應商進行一個簡單的驗證呼叫（例如，列出模型）。
3.  **更新狀態**：
    -   如果驗證成功，憑證的 `active` 標記會被設為 `true`，`error` 欄位會被清除，並且其預設的 `weight` 會被還原。
    -   如果失敗，`error` 欄位會更新為新的失敗原因。

此過程可防止系統重試永久無效的金鑰，從而降低延遲和錯誤率。

## 監控與疑難排解

對於 SRE 和 DevOps 團隊而言，監控憑證池的狀態對於維持系統健康至關重要。

### 關鍵監控點

-   **`active` 狀態**：監控停用憑證的數量。數量突然增加可能表示出現了普遍性問題，例如金鑰過期或供應商端的變更。
-   **`error` 欄位**：對 `AiCredential` 表中 `error` 欄位的非空值進行記錄和警報，以快速識別憑證失敗的根本原因。
-   **`usageCount` 與 `lastUsedAt`**：觀察這些欄位以驗證負載是否按照設定的權重如預期般分發。如果某個憑證的 `usageCount` 沒有增加，它可能處於停用狀態或存在設定問題。

### 疑難排解情境

-   **負載分發不均**：如果請求未按預期進行均衡，請檢查與該供應商相關的所有憑證的 `weight` 值。確保沒有憑證被意外標記為停用。
-   **特定供應商的高錯誤率**：查詢該 `providerId` 的 `ai_credentials` 表。檢查是否有 `active: false` 的憑證，並檢視相應的 `error` 訊息。問題很可能出在一個或多個特定的金鑰上，而不是整個服務。
-   **供應商完全中斷**：如果某個供應商的所有憑證都失敗，問題可能出在上游的 AI 供應商本身。記錄的 `error` 訊息將有助於區分本地憑證問題和外部服務中斷。