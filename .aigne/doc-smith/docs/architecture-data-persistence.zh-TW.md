# 資料持久化

本系統的資料持久層建立在 [Sequelize](https://sequelize.org/)（一個基於 Promise 的 Node.js ORM）之上，並使用 [SQLite](https://www.sqlite.org/index.html) 作為其資料庫引擎。此設計選擇優先考慮了簡易性、部署便利性及最少的外部依賴，使系統能夠自成一體且易於管理。

## 資料庫設定

核心的資料庫設定在 `blocklets/core/api/src/store/sequelize.ts` 中管理。系統會連接到單一的 SQLite 資料庫檔案，確保所有持久化資料都儲存在一個可預測的位置。

-   **連線 URL**：`sqlite:${Config.dataDir}/aikit.db`
-   **資料庫檔案**：位於設定資料目錄中的 `aikit.db`。

### 效能與並行性調校

為了最佳化並行的讀寫操作並提升效能，系統在初始化時設定了數個 SQLite PRAGMA 指令。這些設定對於在高負載下維持系統的回應能力至關重要。

-   `pragma journal_mode = WAL;`：預寫式記錄（Write-Ahead Logging, WAL）模式允許更高的並行性，它讓讀取者在另一處理程序寫入資料庫時仍可繼續操作。這顯著減少了讀寫者之間的競爭。
-   `pragma synchronous = normal;`：在 WAL 模式下，此設定確保寫入交易在返回前已提交至 WAL 檔案，但由作業系統負責實際的磁碟同步時機。這在效能與耐用性之間提供了良好的平衡。
-   `pragma journal_size_limit = 67108864;`：設定 WAL 檔案的大小限制（64 MB），防止其無限增長並消耗過多的磁碟空間。

## 結構管理與遷移

資料庫結構的遷移由 [Umzug](https://github.com/sequelize/umzug) 處理，確保資料庫的變更是以一種受控、版本化且可重複的方式進行。遷移邏輯位於 `blocklets/core/api/src/store/migrate.ts`。

-   **遷移檔案**：遷移被定義為位於 `**/migrations/` 目錄中的 `.ts` 或 `.js` 檔案。Umzug 會在應用程式啟動時自動發現並執行待處理的遷移。
-   **安全的結構更新**：系統包含了如 `safeApplyColumnChanges` 和 `createIndexIfNotExists` 等輔助函式，以防止常見的部署錯誤。這些輔助函式確保結構修改（如新增欄位或索引）僅在它們不存在時才被應用，使遷移腳本具有冪等性且可安全地重複執行。

## 資料模型

資料庫結構由數個相互關聯的模型組成，這些模型代表了系統的核心實體。

### 核心模型概覽

-   **AiProvider**：代表一個外部 AI 服務供應商（例如 OpenAI、AWS Bedrock）。它儲存了如基礎 URL、區域和顯示名稱等設定細節。
-   **AiCredential**：安全地儲存每個 `AiProvider` 的驗證憑證。它包含了對單一供應商的多個憑證進行負載平衡的功能。
-   **AiModelRate**：定義由供應商提供的特定 AI 模型的成本結構與元資料。這用於計算每次 API 呼叫的點數成本。
-   **ModelCall**：作為主要的稽核與交易日誌。每一次 AI 請求都會在此被記錄，捕捉有關使用者、供應商、模型、用量指標以及最終狀態（成功/失敗）的詳細資訊。
-   **ModelCallStat**：一個為效能最佳化而設計的模型，儲存從 `ModelCall` 表中預先彙總的每小時和每日使用統計資料。這用於加速儀表板和分析查詢。
-   **App**：儲存經授權使用本系統的應用程式資訊，包括其用於驗證的公鑰。
-   **Usage**：一個用於追蹤權杖使用量和點數消耗的輔助模型，主要用於向外部支付系統回報。

### `AiCredential`：安全性與負載平衡

`AiCredential` 模型對於安全性與系統可靠性都至關重要。

#### 憑證加密

為了保護敏感資訊，如 `api_key` 和 `secret_access_key` 等憑證值不會以純文字形式儲存。它們在持久化到資料庫之前，會使用 `@blocklet/sdk/lib/security` 模組進行加密。此模型提供了 `encryptCredentialValue` 和 `decryptCredentialValue` 方法來透明地處理此過程。從維運的角度來看，這意味著原始的資料庫檔案不會暴露敏感金鑰，但應用程式的執行環境必須是安全的。

#### 憑證負載平衡

靜態方法 `getNextAvailableCredential` 實作了一種平滑加權輪詢演算法。這允許管理員為單一供應商設定多個憑證，並根據分配的權重將 API 負載分散到這些憑證上。這對於以下場景很有用：

-   **分散速率限制**：將請求分散到多個金鑰上，以避免觸及供應商的速率限制。
-   **高可用性**：如果一個憑證失效，系統可以繼續使用其餘有效的憑證運作。
-   **用量配額管理**：將用量分散到不同的帳戶或計費層級。

該演算法在記憶體中維護每個憑證的當前權重，以選擇最適合下一次請求的憑證，確保流量得到高效且均衡的分配。

### `ModelCall` 與 `ModelCallStat`：分析與效能

本系統旨在提供關於 AI 模型用量的詳細分析，同時維持一個反應靈敏的使用者介面。這是透過雙層資料模型設計來實現的。

1.  **原始資料記錄 (`ModelCall`)**：每一次 API 請求都被記錄為 `ModelCalls` 表中的單一條目。這為稽核、詳細分析和針對特定請求的故障排除提供了細緻、完整的歷史記錄。然而，查詢這個大型資料表以獲取彙總統計資料（例如每日用量趨勢）可能會很慢且耗費資源。

2.  **預先彙總快取 (`ModelCallStat`)**：為了解決效能問題，`ModelCallStat` 模型儲存了 `ModelCall` 中資料的預先計算的每小時和每日摘要。當請求過去某個時期的分析資料時，系統會從這個摘要表中讀取，這樣速度快得多。對於當前正在進行的時期（例如今天或當前小時），統計資料會從 `ModelCall` 表中即時計算以確保新鮮度。這種快取策略是一項關鍵的架構決策，它平衡了資料的準確性與查詢效能。

## 維運考量

### 備份與還原

系統的全部狀態都儲存在 `aikit.db` 這個 SQLite 檔案中。備份這單一檔案足以保存所有資料。

然而，由於使用了 `WAL` 模式，在應用程式執行時直接進行檔案複製（`cp`）是**不被建議的**，因為這可能導致備份檔案損毀。建立即時備份的建議程序是使用 SQLite CLI 的 `.backup` 指令：

```bash
sqlite3 /path/to/your/data/aikit.db ".backup '/path/to/your/backup/aikit.db.backup'"
```

此指令會安全地將資料庫內容複製到一個新檔案，確保即使在資料庫使用中也能獲得一個一致的快照。還原時，只需在應用程式停止的狀態下，用備份檔案取代 `aikit.db` 檔案即可。

### 資料增長管理

`ModelCalls` 表被設計為會無限增長，因為它記錄了每一次 API 交易。對於長期運行的部署，這可能導致顯著的磁碟空間使用，並可能降低詳細歷史搜尋的查詢效能。

系統管理員應監控 `aikit.db` 檔案的大小。雖然應用程式沒有內建的資料清理或封存機制，但可能需要根據用量來實施一套策略。潛在的策略可能包括定期將早於某個日期的 `ModelCall` 記錄封存至冷儲存，然後從線上資料庫中刪除它們。