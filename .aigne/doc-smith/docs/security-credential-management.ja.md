# 負荷分散

AIGNE Hub は、単一プロバイダーに対する複数の資格情報に AI リクエストを分散させるための堅牢な負荷分散メカニズムを提供します。これは、API レート制限の管理、耐障害性の向上、およびコストの最適化に不可欠です。このシステムは、インテリジェントな分散と資格情報障害に対する回復力の両方を備えるように設計されています。

このドキュメントでは、負荷分散システムのアーキテクチャ、使用されるアルゴリズム、およびインフラストラクチャチーム向けの運用上の考慮事項について説明します。

## アーキテクチャ概要

単一の AI プロバイダーに対して複数の API キーまたは資格情報が設定されている場合 (例: 複数の OpenAI API キー)、AIGNE Hub はそれらをリソースのプールとして扱います。そのプロバイダー向けの各着信リクエストに対して、ロードバランサーはスムーズ加重ラウンドロビンアルゴリズムに基づいて、プールから最も適切な資格情報を選択します。

このシステムの主要コンポーネントは次のとおりです。

-   **資格情報プール**: 特定のプロバイダーのアクティブな資格情報のコレクション。
-   **重み付けシステム**: 各資格情報には、選択される頻度に影響を与えるための `weight` (重み) を割り当てることができます。
-   **ヘルスステータス**: 資格情報は `active` (アクティブ) または `inactive` (非アクティブ) としてマークできます。ロードバランサーはアクティブな資格情報のプールからのみ選択します。
-   **使用状況の追跡**: システムは各資格情報の `usageCount` (使用回数) と `lastUsedAt` (最終使用日時) を追跡します。これはフェイルオーバーに役立ち、分散の可視性を提供します。

---

## 負荷分散アルゴリズム

AIGNE Hub は、**スムーズ加重ラウンドロビン (Smooth Weighted Round-Robin)** アルゴリズムを採用して、事前に定義された重みに従ってリクエストを公正かつ予測可能に分散します。

### 仕組み

このアルゴリズムは、重みの高い単一の資格情報へのリクエストの集中を避けるように設計されています。代わりに、リクエストをスムーズに分散させます。各リクエストの選択プロセスは次のとおりです。

1.  **アクティブな資格情報の取得**: システムは、対象プロバイダーの `active` フラグが `true` であるすべての資格情報を取得します。
2.  **現在の重みの更新**: インメモリキャッシュが各資格情報の `current` (現在) の重みを維持します。選択が実行されるたびに、各資格情報の設定された `weight` がその `current` の重みに加算されます。
3.  **最適な資格情報の選択**: `current` の重みが最も高い資格情報が、リクエストを処理するために選択されます。
4.  **次のサイクルのための調整**: 選択後、プール内のすべての資格情報の `total weight` (合計の重み) が、選択された資格情報の `current` の重みから減算されます。

このプロセスにより、重みの高い資格情報が時間の経過とともにより頻繁に選択されるようになりますが、それは交互かつスムーズな方法で行われます。

### 設定

分散は、各資格情報の `weight` パラメータによって制御されます。

-   **`weight` (integer)**: デフォルトは `100` です。数値が高いほど、その資格情報に送信されるリクエストの割合が増加します。

**シナリオ例:**

あるプロバイダーに2つの資格情報があるとします。
-   **Key-A**: `weight: 200`
-   **Key-B**: `weight: 100`

300回のリクエストのうち、**Key-A** は約200回のリクエストを処理するために選択され、**Key-B** は約100回を処理します。スムーズアルゴリズムにより、分散が均等になり、例えば Key-A が連続して200回のリクエストを受信することを防ぎます。

### コード実装

中核となるロジックは、`AiCredential` モデルの `getNextAvailableCredential` 静的メソッドにあります。このメソッドは、重みの計算を管理し、次の資格情報を選択します。

```typescript
// 出典: blocklets/core/api/src/store/models/ai-credential.ts

// スムーズ加重ラウンドロビンの簡略化されたロジック
let selected: AiCredential | null = null;
for (const c of credentials) {
  const w = weights[c.id];
  if (w) {
    w.current += w.weight;
    if (!selected || w.current > weights[selected.id]!.current) {
      selected = c;
    }
  }
}

if (selected) {
  weights[selected.id]!.current -= totalWeight;
}

return selected;
```

---

## フェイルオーバーとヘルス管理

ロードバランサーは、障害が発生した資格情報を自動的にバイパスし、サービスの継続性を確保するように設計されています。

### 自動的な無効化

資格情報固有の問題 (例: 無効な API キー) が原因で AI プロバイダーへのリクエストが失敗した場合、その資格情報は非アクティブとしてマークされることがあります。

-   `active` フラグが `false` に設定されます。
-   障害の原因を詳述する `error` メッセージが、資格情報レコードに対してログに記録されます。

資格情報が非アクティブとしてマークされると、ロードバランサーは後続のリクエストの選択プールからそれを直ちに削除します。

### 資格情報の再有効化

非アクティブとマークされた資格情報は、手動で再検証および再有効化する必要があります。この目的のために `checkCredentials` 関数が使用されます。

1.  **検証のトリガー**: 管理者は、管理インターフェースを通じて非アクティブな資格情報のヘルスチェックをトリガーできます。
2.  **接続テスト**: システムは資格情報を使用して AI プロバイダーに簡単な検証呼び出し (例: モデルのリスト表示) を行います。
3.  **ステータスの更新**:
    -   検証が成功した場合、資格情報の `active` フラグが `true` に設定され、`error` フィールドがクリアされ、デフォルトの `weight` が復元されます。
    -   失敗した場合、`error` フィールドが新しい失敗理由で更新されます。

このプロセスにより、恒久的に無効なキーが再試行されるのを防ぎ、レイテンシとエラー率を削減します。

## 監視とトラブルシューティング

SRE および DevOps チームにとって、健全なシステムを維持するためには、資格情報プールの状態を監視することが重要です。

### 主要な監視ポイント

-   **`active` ステータス**: 非アクティブな資格情報の数を監視します。急激な増加は、キーの有効期限切れやプロバイダー側の変更など、広範な問題を示唆する可能性があります。
-   **`error` フィールド**: 資格情報障害の根本原因を迅速に特定するために、`AiCredential` テーブルの `error` フィールドの null でない値をログに記録し、アラートを発します。
-   **`usageCount` と `lastUsedAt`**: これらのフィールドを監視して、設定された重みに従って負荷が期待どおりに分散されていることを確認します。資格情報の `usageCount` が増加していない場合、非アクティブであるか、設定に問題がある可能性があります。

### トラブルシューティングシナリオ

-   **負荷分散の不均衡**: リクエストが期待どおりに分散されていない場合は、プロバイダーに関連付けられているすべての資格情報の `weight` 値を確認します。予期せず非アクティブにマークされた資格情報がないことを確認してください。
-   **プロバイダーの高いエラー率**: `ai_credentials` テーブルでその `providerId` をクエリします。`active: false` の資格情報がないか確認し、対応する `error` メッセージを確認します。問題はサービス全体ではなく、1つまたは複数の特定のキーにある可能性が高いです。
-   **プロバイダーの完全な停止**: あるプロバイダーのすべての資格情報が失敗している場合、問題は AI プロバイダー自体の上流にある可能性があります。ログに記録された `error` メッセージは、ローカルの資格情報の問題と外部サービスの停止を区別するのに役立ちます。