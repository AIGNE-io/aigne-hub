# 利用状況と分析

このドキュメントでは、AIモデルの利用状況と分析を追跡、計算、報告するためのシステムアーキテクチャについて詳しく概説します。システムのデプロイと保守を担当するDevOps、SRE、およびインフラストラクチャチームを対象としています。

## 1. コアコンセプト

分析システムは、個々のAPIコールをすべて追跡し、関連するコストをクレジットで計算し、効率的な報告と分析のためにこのデータを集計するという3つの主要なコンセプトに基づいています。

### 1.1 モデルコールの追跡

AIモデルへのすべてのリクエストは、データベースに`ModelCall`レコードとして綿密に記録されます。これは、すべての利用状況データにおける信頼できる唯一の情報源として機能します。

#### モデルコールのライフサイクル

`ModelCall`レコードは、`createModelCallMiddleware`によって管理される明確なライフサイクルを経て進行します。

1.  **処理中 (Processing)**: APIリクエストを受信すると、直ちに`processing`ステータスの`ModelCall`エントリが作成されます。リクエストオブジェクトに`modelCallContext`オブジェクトが添付され、下流のサービスがこのレコードを更新できるようになります。
2.  **完了 (Completion)**: AIモデルプロバイダーから正常なレスポンスを受け取ると、コンテキストの`complete`メソッドが呼び出されます。これにより、レコードのステータスが`success`に更新され、トークン数、消費クレジット、合計所要時間などの最終的な利用状況メトリクスが入力されます。
3.  **失敗 (Failure)**: プロセス中に何らかのエラー（APIエラー、ネットワークの問題、内部処理の失敗など）が発生した場合、コンテキストの`fail`メソッドが呼び出されます。ステータスは`failed`に設定され、特定のエラーメッセージが記録されます。これにより、失敗したリクエストでさえも監視とデバッグのために追跡されることが保証されます。

このライフサイクルにより、どのAPIコールも失われることなく、成功した操作と失敗した操作の両方に対する完全な可視性が提供されます。

### 1.2 クレジット計算と利用状況報告

このシステムは、利用状況（例：トークン、画像生成）を標準化された`credits`単位に変換するクレジットベースの課金モデルで運用されます。

#### 計算

クレジット計算は`createUsageAndCompleteModelCall`関数によって実行されます。モデルコールが完了すると、この関数は次の処理を行います。
1.  特定のモデルとコールタイプ（例：チャット補完の入出力レート、画像生成の画像ごとのレート）の価格レートをシステムの設定から取得します。
2.  `BigNumber.js`を使用して消費された合計クレジットを計算し、高い精度を確保し、浮動小数点数の不正確さを回避します。
3.  計算されたクレジットを対応する`ModelCall`レコードに保存します。

#### 非同期報告

パフォーマンスと回復性を最適化するため、クレジット利用状況は外部の課金システムに非同期で報告されます。

1.  **スロットリング**: `reportUsageV2`関数は`lodash/throttle`を使用してスロットリングされます。個々のAPIコールごとに課金イベントを送信する代わりに、システムは設定可能な期間（`usageReportThrottleTime`）にわたるユーザーの利用状況を集計し、単一の統合されたイベントを送信します。これにより、課金サービスへの負荷が大幅に軽減されます。
2.  **アトミックな更新**: 分散環境やマルチプロセス環境でのデータ損失や二重計上を防ぐため、システムはアトミックな更新戦略を採用しています。利用状況レコードはまず`counted`としてマークされ、次に集計され、最後に課金サービスへのAPIコールが成功した後に`reported`としてマークされます。報告が失敗した場合、レコードは`counted`状態のまま（または`null`にリセットされ）、後続の再試行のために残ります。

### 1.3 データの集計とキャッシュ

ダッシュボードの高速な読み込みと効率的な分析クエリを保証するため、システムは事前集計キャッシュレイヤーを使用します。

-   **生データ**: `ModelCall`テーブルには、リクエストごとの詳細なデータが含まれています。詳細な監査やログには不可欠ですが、広範な日付範囲にわたる時系列分析のためにクエリを実行すると、処理が遅くなる可能性があります。
-   **集計データ**: `ModelCallStat`テーブルには、各ユーザーの日次および時間単位の事前計算されたサマリーが保存されます。Cronジョブ（`model.call.stats`）が定期的に実行され、生の`ModelCall`データからこれらのサマリーを計算して保存します。ダッシュボードや統計エンドポイントは主にこのキャッシュされたテーブルにクエリを実行するため、レスポンスタイムが大幅に向上します。

## 2. システムアーキテクチャとデータフロー

以下の手順は、APIリクエストの受信から最終的な集計分析までのデータフローの概要です。

1.  **リクエストの傍受**: 受信したAPIリクエスト（例：`/v1/chat/completions`）は`createModelCallMiddleware`によって傍受されます。
2.  **初期レコードの作成**: ミドルウェアは`status: 'processing'`の`ModelCall`レコードを作成し、リクエストされたモデル、ユーザーDID、リクエストタイムスタンプなどの初期メタデータをキャプチャします。
3.  **プロバイダーとの対話**: リクエストは適切なAIプロバイダーに転送されます。ミドルウェアは解決された認証情報と最終的なモデル名で`ModelCall`レコードを更新します。
4.  **利用状況の計算**: レスポンスを受信すると、`createUsageAndCompleteModelCall`関数が呼び出されます。この関数はトークン使用量と対応するクレジットを計算します。
5.  **利用状況レコードの作成**: 新しい`Usage`レコードが作成され、課金システムへのトランザクションがキューに入れられます。
6.  **非同期報告**: スロットリングされた`reportUsageV2`関数がトリガーされます。この関数はユーザーの未報告の`Usage`レコードをすべて集計し、単一の`createMeterEvent`を支払い/課金サービスに送信します。
7.  **ModelCallの最終処理**: `ModelCall`レコードは`success`または`failed`に更新され、所要時間、トークン数、クレジットなどの最終的なメトリクスが記録されます。
8.  **スケジュールされた集計**: `model.call.stats` cronジョブが定期的に実行され、`ModelCall`テーブルにクエリを実行して時間単位および日単位のサマリーを計算し、それらを`ModelCallStat`テーブルに保存します。

## 3. 主要コンポーネント

### 3.1 APIエンドポイント

`routes/user.ts`で定義されている以下のエンドポイントは、利用状況と分析データへのアクセスを提供します。

| エンドポイント | メソッド | 説明 |
| :--- | :--- | :--- |
| `/api/user/model-calls` | `GET` | 生の`ModelCall`レコードのページ分割されたリストを取得します。日付、ステータス、モデル、ユーザーによるフィルタリングをサポートします。管理者向けに`allUsers=true`パラメータが利用可能です。 |
| `/api/user/model-calls/export` | `GET` | `ModelCall`データをCSVファイルにエクスポートします。リストエンドポイントと同じフィルターが適用されます。 |
| `/api/user/usage-stats` | `GET` | 現在のユーザーのダッシュボード用の集計利用統計情報を取得します。主に`ModelCallStat`キャッシュから取得します。 |
| `/api/user/admin/user-stats` | `GET` | (管理者のみ) すべてのユーザーの集計利用統計情報を取得します。 |
| `/api/user/recalculate-stats` | `POST` | (管理者のみ) 指定された期間のユーザーの統計情報を手動で再計算します。これはデータ修正のための重要なツールです。 |
| `/api/user/cleanup-daily-stats` | `POST` | (管理者のみ) 指定された期間内のユーザーのキャッシュされた日次統計情報を削除し、次回のクエリで新たに計算させます。 |

### 3.2 Cronジョブ

スケジュールされたタスクは、分析システムの健全性と正確性を維持するために不可欠です。

| ジョブ名 | スケジュール | 説明 |
| :--- | :--- | :--- |
| `cleanup.stale.model.calls` | `CLEANUP_STALE_MODEL_CALLS_CRON_TIME` | サーバーのクラッシュや未処理のエラーにより、長期間（例：30分以上）`processing`状態のままになっている`ModelCall`レコードをスキャンします。データ整合性を確保するために、それらを`failed`としてマークします。 |
| `model.call.stats` | `MODEL_CALL_STATS_CRON_TIME` | `ModelCall`テーブルからデータを集計して`ModelCallStat`テーブルを更新します。これは分析キャッシングメカニズムの中核です。 |

## 4. トラブルシューティングとメンテナンス

### 4.1 古い、または「スタックした」処理中コール

**現象**: `ModelCall`レコードが`processing`状態のまま無期限に残る。
**原因**: サーバーインスタンスがモデルコールの開始後、完了または失敗としてマークされる前に予期せず終了した場合に発生する可能性があります。
**解決策**: `cleanup.stale.model.calls` cronジョブが、タイムアウトしたコールを失敗としてマークすることで自動的に解決します。タイムアウトは設定可能です（デフォルト：30分）。通常、手動での介入は必要ありません。

### 4.2 ダッシュボードの不正確な統計情報

**現象**: ユーザー向けまたは管理者向けダッシュボードに、利用状況、コール数、またはクレジットの合計が不正確に表示される。
**原因**: 過去の集計ロジックのバグや、失敗したcronジョブの実行により`ModelCallStat`キャッシュが不整合な状態になったことが考えられます。
**解決策**: 管理者専用の`/api/user/recalculate-stats`エンドポイントを使用します。

**統計情報を再計算するためのリクエスト例:**

```bash
curl -X POST \
  -H "Authorization: Bearer <ADMIN_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{
    "userDid": "z1...userDid",
    "startTime": 1672531200,
    "endTime": 1675209599,
    "dryRun": false
  }' \
  https://your-instance.com/api/user/recalculate-stats
```

-   `userDid`: 統計情報の修正が必要なユーザーのDID。
-   `startTime`/`endTime`: 再計算期間を定義するUnixタイムスタンプ。
-   `dryRun`: データベースに書き込まずに変更をプレビューするには`true`に設定します。

このプロセスは、指定された範囲内の既存のキャッシュされた統計情報を削除し、生の`ModelCall`データから再生成することで、正確性を保証します。