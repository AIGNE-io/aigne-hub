# 负载均衡

AIGNE Hub 提供了一个强大的负载均衡机制，用于将针对单个提供商的 AI 请求分发到多个凭证上。这对于管理 API 速率限制、提高容错能力和优化成本至关重要。该系统在设计上兼顾了分发的智能性和对凭证故障的弹性。

本文档将解释该负载均衡系统的架构、所使用的算法以及针对基础设施团队的运维注意事项。

## 架构概述

当为单个 AI 提供商（例如，多个 OpenAI API 密钥）配置了多个 API 密钥或凭证时，AIGNE Hub 会将它们视为一个资源池。对于每一个指向该提供商的传入请求，负载均衡器会基于平滑加权轮询算法从池中选择最合适的凭证。

该系统的关键组件包括：

-   **凭证池**：特定提供商的活动凭证的集合。
-   **权重系统**：可以为每个凭证分配一个 `weight`（权重），以影响其被选中的频率。
-   **健康状态**：凭证可以被标记为 `active`（活动）或 `inactive`（非活动）。负载均衡器只会从活动凭证池中进行选择。
-   **使用情况跟踪**：系统会跟踪每个凭证的 `usageCount`（使用次数）和 `lastUsedAt`（最后使用时间），这有助于故障转移并提供分发情况的可见性。

---

## 负载均衡算法

AIGNE Hub 采用**平滑加权轮询**（Smooth Weighted Round-Robin）算法，以确保根据预定义的权重对请求进行公平且可预测的分发。

### 工作原理

该算法旨在避免将请求突发性地发送到单个高权重凭证，而是平滑地将它们分散开。以下是每次请求的选择过程：

1.  **检索活动凭证**：系统获取目标提供商所有 `active` 标志为 `true` 的凭证。
2.  **更新当前权重**：内存缓存中维护了每个凭证的 `current`（当前）权重。在每次选择运行时，每个凭证配置的 `weight`（权重）都会被加到其 `current` 权重上。
3.  **选择最佳凭证**：选择 `current` 权重最高的凭证来处理请求。
4.  **为下一周期调整**：选择之后，凭证池中所有凭证的 `total weight`（总权重）会从被选中凭证的 `current` 权重中减去。

此过程确保了权重较高的凭证会随着时间的推移被更频繁地选择，但选择方式是交错且平滑的。

### 配置

分发由每个凭证上的 `weight` 参数控制。

-   **`weight` (integer)**：默认为 `100`。数值越高，发送到该凭证的请求比例就越大。

**示例场景：**

假设一个提供商有两个凭证：
-   **Key-A**：`weight: 200`
-   **Key-B**：`weight: 100`

在一系列 300 次请求中，**Key-A** 大约会被选中处理 200 次请求，而 **Key-B** 将处理约 100 次。平滑算法确保了分发的均匀性，避免了（例如）Key-A 连续接收 200 次请求的情况。

### 代码实现

核心逻辑位于 `AiCredential` 模型的 `getNextAvailableCredential` 静态方法中。该方法管理权重计算并选择下一个凭证。

```typescript
// 来自：blocklets/core/api/src/store/models/ai-credential.ts

// 平滑加权轮询的简化逻辑
let selected: AiCredential | null = null;
for (const c of credentials) {
  const w = weights[c.id];
  if (w) {
    w.current += w.weight;
    if (!selected || w.current > weights[selected.id]!.current) {
      selected = c;
    }
  }
}

if (selected) {
  weights[selected.id]!.current -= totalWeight;
}

return selected;
```

---

## 故障转移与健康管理

负载均衡器旨在自动绕过发生故障的凭证，以确保服务的连续性。

### 自动停用

如果因凭证特定问题（例如，API 密钥无效）导致向 AI 提供商的请求失败，该凭证可被标记为非活动状态。

-   `active` 标志被设置为 `false`。
-   一条详细说明失败原因的 `error` 消息会被记录到该凭证的记录中。

一旦凭证被标记为非活动，负载均衡器会立即将其从后续请求的选择池中移除。

### 凭证重新激活

被标记为非活动的凭证必须手动重新验证和重新激活。`checkCredentials` 函数用于此目的。

1.  **触发验证**：管理员可以通过管理界面对非活动凭证触发健康检查。
2.  **测试连接**：系统使用该凭证向 AI 提供商发起一个简单的验证调用（例如，列出模型）。
3.  **更新状态**：
    -   如果验证成功，凭证的 `active` 标志将被设置为 `true`，`error` 字段被清空，其默认的 `weight` 也会被恢复。
    -   如果失败，`error` 字段将更新为新的失败原因。

此过程可防止系统重试永久无效的密钥，从而降低延迟和错误率。

## 监控与故障排查

对于 SRE 和 DevOps 团队而言，监控凭证池的状态对于维护系统健康至关重要。

### 关键监控点

-   **`active` 状态**：监控非活动凭证的数量。数量突然增加可能预示着一个普遍性问题，例如密钥过期或提供商端的变更。
-   **`error` 字段**：对 `AiCredential` 表中 `error` 字段的非空值进行日志记录和告警，以便快速识别凭证失败的根本原因。
-   **`usageCount` 和 `lastUsedAt`**：观察这些字段以验证负载是否按配置的权重如期分配。如果某个凭证的 `usageCount` 没有增加，它可能处于非活动状态或存在配置问题。

### 故障排查场景

-   **负载分配不均**：如果请求未按预期进行均衡，请核实与该提供商关联的所有凭证的 `weight` 值。确保没有凭证被意外标记为非活动。
-   **某个提供商的高错误率**：查询该 `providerId` 对应的 `ai_credentials` 表。检查是否有 `active: false` 的凭证，并查看相应的 `error` 消息。问题很可能出在一个或多个特定密钥上，而不是整个服务。
-   **提供商完全中断**：如果某个提供商的所有凭证都失败了，问题可能出在上游的 AI 提供商本身。记录的 `error` 消息将有助于区分本地凭证问题和外部服务中断。