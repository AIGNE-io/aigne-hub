# 数据持久化

系统的持久化层基于 [Sequelize](https://sequelize.org/)（一个基于 Promise 的 Node.js ORM）构建，并使用 [SQLite](https://www.sqlite.org/index.html) 作为其数据库引擎。这一设计选择优先考虑了简单性、易于部署和最小化外部依赖，使得系统自成一体且易于管理。

## 数据库配置

核心数据库配置在 `blocklets/core/api/src/store/sequelize.ts` 中进行管理。系统连接到单个 SQLite 数据库文件，确保所有持久化数据都存储在可预测的位置。

-   **连接 URL**：`sqlite:${Config.dataDir}/aikit.db`
-   **数据库文件**：位于已配置数据目录中的 `aikit.db`。

### 性能与并发调优

为优化并发读/写操作并提升性能，系统在初始化时设置了多项 SQLite PRAGMA 指令。这些设置对于在负载下保持系统响应能力至关重要。

-   `pragma journal_mode = WAL;`：预写式日志（WAL）模式允许更高的并发性，它让读取者在另一个进程向数据库写入时仍能继续操作。这显著减少了读写冲突。
-   `pragma synchronous = normal;`：在 WAL 模式下，此设置确保写事务在返回前被提交到 WAL 文件，但由操作系统负责实际的磁盘同步时机。这在性能和持久性之间提供了良好的平衡。
-   `pragma journal_size_limit = 67108864;`：为 WAL 文件的大小设置一个限制（64 MB），防止其无限增长并消耗过多的磁盘空间。

## 模式管理与迁移

数据库模式迁移由 [Umzug](https://github.com/sequelize/umzug) 处理，确保数据库变更以受控、版本化和可重复的方式应用。迁移逻辑位于 `blocklets/core/api/src/store/migrate.ts` 中。

-   **迁移文件**：迁移被定义为位于 `**/migrations/` 目录下的 `.ts` 或 `.js` 文件。Umzug 会在应用程序启动时自动发现并执行待处理的迁移。
-   **安全的模式更新**：系统包含诸如 `safeApplyColumnChanges` 和 `createIndexIfNotExists` 之类的辅助函数，以防止常见的部署错误。这些辅助函数确保模式修改（如添加列或索引）仅在它们尚不存在时才被应用，从而使迁移脚本具有幂等性且可以安全地重复运行。

## 数据模型

数据库模式被组织成几个相互关联的模型，代表了系统的核心实体。

### 核心模型概览

-   **AiProvider**：代表外部 AI 服务提供商（例如 OpenAI、AWS Bedrock）。它存储了基础 URL、区域和显示名称等配置详情。
-   **AiCredential**：安全地存储每个 `AiProvider` 的身份验证凭据。它包含对单个提供商的多个凭据进行负载均衡的功能。
-   **AiModelRate**：定义了提供商提供的特定 AI 模型的成本结构和元数据。这用于计算每次 API 调用的积分成本。
-   **ModelCall**：作为主要的审计和事务日志。每个 AI 请求都会在此处记录，捕获有关用户、提供商、模型、使用指标和最终状态（成功/失败）的详细信息。
-   **ModelCallStat**：一个性能优化模型，用于存储从 `ModelCall` 表派生的预聚合每小时和每日使用统计数据。这用于加速仪表盘和分析查询。
-   **App**：存储有关被授权使用系统的应用程序的信息，包括其用于身份验证的公钥。
-   **Usage**：一个辅助模型，用于跟踪 token 使用和积分消耗，主要用于向外部支付系统报告。

### `AiCredential`：安全性与负载均衡

`AiCredential` 模型对安全性和系统可靠性都至关重要。

#### 凭据加密

为了保护敏感信息，像 `api_key` 和 `secret_access_key` 这样的凭据值不会以明文形式存储。它们在使用 `@blocklet/sdk/lib/security` 模块持久化到数据库之前会被加密。该模型提供了 `encryptCredentialValue` 和 `decryptCredentialValue` 方法来透明地处理此过程。从操作角度来看，这意味着原始数据库文件不会暴露敏感密钥，但应用程序的运行时环境必须是安全的。

#### 凭据负载均衡

`getNextAvailableCredential` 静态方法实现了一种平滑加权轮询算法。这允许管理员为单个提供商配置多个凭据，并根据分配的权重将 API 负载分散到这些凭据上。这对于以下方面很有用：

-   **速率限制分配**：将请求分散到多个密钥上，以避免达到提供商的速率限制。
-   **高可用性**：如果一个凭据失效，系统可以继续使用剩余的活动凭据运行。
-   **使用配额管理**：将使用量分配到不同的账户或计费层级。

该算法在内存中维护每个凭据的当前权重，以便为下一个请求选择最合适的凭据，从而确保流量的高效和均衡分配。

### `ModelCall` 与 `ModelCallStat`：分析与性能

系统旨在提供关于 AI 模型使用情况的详细分析，同时保持响应迅速的用户界面。这是通过一个双层数据模型设计实现的。

1.  **原始数据日志记录 (`ModelCall`)**：每个 API 请求都在 `ModelCalls` 表中被记录为单个条目。这为审计、详细分析和排查特定请求提供了粒度化、完整的历史记录。然而，查询这个大表以获取聚合统计数据（例如，每日使用趋势）可能会很慢且资源消耗大。

2.  **预聚合缓存 (`ModelCallStat`)**：为解决性能问题，`ModelCallStat` 模型存储了 `ModelCall` 中数据的预计算每小时和每日摘要。当请求过去时间段的分析数据时，系统会从这个摘要表中读取，这要快得多。对于当前正在进行的时期（例如，今天或当前小时），统计数据会从 `ModelCall` 表中实时计算以确保数据的新鲜度。这种缓存策略是一项关键的架构决策，它平衡了数据准确性与查询性能。

## 运维考量

### 备份与恢复

系统的整个状态都存储在 `aikit.db` SQLite 文件中。备份这单个文件足以保存所有数据。

然而，由于使用了 `WAL` 模式，**不推荐**在应用程序运行时直接进行文件复制（`cp`），因为这可能导致备份文件损坏。创建实时备份的推荐步骤是使用 SQLite CLI 的 `.backup` 命令：

```bash
sqlite3 /path/to/your/data/aikit.db ".backup '/path/to/your/backup/aikit.db.backup'"
```

此命令会安全地将数据库内容复制到一个新文件中，确保即使在数据库正在使用时也能获得一致的快照。恢复操作很简单，只需在应用程序停止时用备份文件替换 `aikit.db` 文件即可。

### 数据增长管理

`ModelCalls` 表被设计为无限增长，因为它记录了每一次 API 事务。对于长期运行的部署，这可能导致大量的磁盘空间占用，并可能降低详细历史搜索的查询性能。

系统管理员应监控 `aikit.db` 文件的大小。虽然应用程序没有内置的数据修剪或归档机制，但可能需要根据使用量来实施相应策略。潜在的策略可以包括定期将超过特定日期的 `ModelCall` 记录归档到冷存储，然后从实时数据库中删除它们。